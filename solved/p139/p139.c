#include <stdio.h>
#include <stdlib.h>

/* we have a few conditions that lead to a relatively simple solution.
 * Let h == the length of the side of the hole.
 * Also let a < b.
 *
 * Then b - a == h.
 *
 * For a tiling to be possible, we require c == h * r, for some integer r > 0
 *
 * We also have a^2 + b^2 == c^2.
 *
 * Combining these, we get:
 * a^2 + (a + h)^2 == h^2 r^2,
 * or:
 * 2 a^2 == h (h*(r-1) - 2a).
 *
 * So we know that either h divides 2 or h divides a.
 * The former case is easy, h divides 2 => h == 1 or 2.
 *
 * The latter case implies:
 *   a = h*s, so
 *
 *   h^2 (s^2 + (s+1)^2) == h^2 r^2,
 *
 *   i.e. (s, s+1, r) is a valid pythagorean tiling with h=1.
 *
 * So now we know that any solution either:
 *   1) has h=2, or:
 *   2) is a multiple of a solution for h=1.
 *
 * The strategy is simple.  First I go through and count up the solutions
 * with h=2 that are *not* generated by a h=1 solution (it turns out that there
 * aren't any).  Then I go through and compute all of the h=1 solutions, and
 * count up the number of generated solutions with their perimeter in the
 * appropriate range.
*/

#define MAX_PERIM 100000000
#define MAX_SIDE ((MAX_PERIM + 1) / 2)

inline int is_generated(long a, long b, long c) {
    return !((a & 1) || (b & 1) || (c & 1));
}

int main(void)
{
    // generate array of squares
    long *squares = malloc(MAX_PERIM*sizeof(long));
    long a;
    for(a = 0; a < MAX_PERIM; a++)
        squares[a] = a*a;

    // first count cases where hole_size == 2 is a solution not generated by
    // a hole_size == 1 case
    long result = 0;
    long c = 0;
    for(a = 1; a < MAX_SIDE; a++) {
        long b = a + 2;
        long c2 = a*a + b*b;

        while(squares[c] < c2)
            c++;

        if(squares[c] == c2 && !is_generated(a, b, c)) {
            long perim = a + b + c;
            printf("non-generated h=2 solution with perimeter %ld, %ld valid solutions: %ld^2 + %ld^2 == %ld^2\n", perim, MAX_PERIM / perim, a, b, c);
            result++;
        }
    }

    c = 0;
    for(a = 1; a < MAX_SIDE; a++) {
        long b = a + 1;
        long c2 = a*a + b*b;

        while(squares[c] < c2)
            c++;

        if(squares[c] != c2)
            continue;
       
        long perim = a + b + c;
        if(perim >= MAX_PERIM)
            break;

        printf("generator with perimeter %ld, %ld valid solutions: %ld^2 + %ld^2 == %ld^2\n", perim, MAX_PERIM / perim, a, b, c);

        result += MAX_PERIM / perim;
    }

    printf("total: %ld solutions\n", result);

    return 0;
}
